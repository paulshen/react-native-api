/**
 * @generated
 */
var React = require("React");
var Layout = require("AutodocsLayout");
var content = `\{
  "methods": [
    \{
      "line": 279,
      "source": "create: function (config) \{\\n    const interactionState = \{\\n      handle: (null: ?number),\\n    };\\n    const gestureState = \{\\n      // Useful for debugging\\n      stateID: Math.random(),\\n    };\\n    PanResponder._initializeGestureState(gestureState);\\n    const panHandlers = \{\\n      onStartShouldSetResponder: function (e) \{\\n        return config.onStartShouldSetPanResponder === undefined ?\\n          false :\\n          config.onStartShouldSetPanResponder(e, gestureState);\\n      },\\n      onMoveShouldSetResponder: function (e) \{\\n        return config.onMoveShouldSetPanResponder === undefined ?\\n          false :\\n          config.onMoveShouldSetPanResponder(e, gestureState);\\n      },\\n      onStartShouldSetResponderCapture: function (e) \{\\n        // TODO: Actually, we should reinitialize the state any time\\n        // touches.length increases from 0 active to > 0 active.\\n        if (e.nativeEvent.touches.length === 1) \{\\n          PanResponder._initializeGestureState(gestureState);\\n        }\\n        gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\\n        return config.onStartShouldSetPanResponderCapture !== undefined ?\\n          config.onStartShouldSetPanResponderCapture(e, gestureState) :\\n          false;\\n      },\\n\\n      onMoveShouldSetResponderCapture: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        // Responder system incorrectly dispatches should* to current responder\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return false;\\n        }\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        return config.onMoveShouldSetPanResponderCapture ?\\n          config.onMoveShouldSetPanResponderCapture(e, gestureState) :\\n          false;\\n      },\\n\\n      onResponderGrant: function (e) \{\\n        if (!interactionState.handle) \{\\n          interactionState.handle = InteractionManager.createInteractionHandle();\\n        }\\n        gestureState.x0 = currentCentroidX(e.touchHistory);\\n        gestureState.y0 = currentCentroidY(e.touchHistory);\\n        gestureState.dx = 0;\\n        gestureState.dy = 0;\\n        if (config.onPanResponderGrant) \{\\n          config.onPanResponderGrant(e, gestureState);\\n        }\\n        // TODO: t7467124 investigate if this can be removed\\n        return config.onShouldBlockNativeResponder === undefined ?\\n          true :\\n          config.onShouldBlockNativeResponder();\\n      },\\n\\n      onResponderReject: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);\\n      },\\n\\n      onResponderRelease: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderStart: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        if (config.onPanResponderStart) \{\\n          config.onPanResponderStart(e, gestureState);\\n        }\\n      },\\n\\n      onResponderMove: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        // Guard against the dispatch of two touch moves when there are two\\n        // simultaneously changed touches.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return;\\n        }\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        if (config.onPanResponderMove) \{\\n          config.onPanResponderMove(e, gestureState);\\n        }\\n      },\\n\\n      onResponderEnd: function (e) \{\\n        const touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);\\n      },\\n\\n      onResponderTerminate: function (e) \{\\n        clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderTerminationRequest: function (e) \{\\n        return config.onPanResponderTerminationRequest === undefined ?\\n          true :\\n          config.onPanResponderTerminationRequest(e, gestureState);\\n      }\\n    };\\n    return \{\\n      panHandlers,\\n      getInteractionHandle(): ?number \{\\n        return interactionState.handle;\\n      },\\n    };\\n  }",
      "docblock": "/**\\n   * @param \{object} config Enhanced versions of all of the responder callbacks\\n   * that provide not only the typical \`ResponderSyntheticEvent\`, but also the\\n   * \`PanResponder\` gesture state.  Simply replace the word \`Responder\` with\\n   * \`PanResponder\` in each of the typical \`onResponder*\` callbacks. For\\n   * example, the \`config\` object would look like:\\n   *\\n   *  - \`onMoveShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onMoveShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderReject: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderGrant: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderStart: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderEnd: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderRelease: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderMove: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminate: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminationRequest: (e, gestureState) => \{...}\`\\n   *  - \`onShouldBlockNativeResponder: (e, gestureState) => \{...}\`\\n   *\\n   *  In general, for events that have capture equivalents, we update the\\n   *  gestureState once in the capture phase and can use it in the bubble phase\\n   *  as well.\\n   *\\n   *  Be careful with onStartShould* callbacks. They only reflect updated\\n   *  \`gestureState\` for start/end events that bubble/capture to the Node.\\n   *  Once the node is the responder, you can rely on every start/end event\\n   *  being processed by the gesture and \`gestureState\` being updated\\n   *  accordingly. (numberActiveTouches) may not be totally accurate unless you\\n   *  are the responder.\\n   */\\n",
      "modifiers": [
        "static"
      ],
      "params": [
        \{
          "typehint": "\{\\"type\\":\\"simple\\",\\"value\\":\\"object\\",\\"length\\":1}",
          "name": "config"
        }
      ],
      "tparams": null,
      "returntypehint": null,
      "name": "create"
    }
  ],
  "properties": [],
  "classes": [],
  "superClass": null,
  "type": "api",
  "line": 122,
  "name": "PanResponder",
  "docblock": "/**\\n * \`PanResponder\` reconciles several touches into a single gesture. It makes\\n * single-touch gestures resilient to extra touches, and can be used to\\n * recognize simple multi-touch gestures.\\n *\\n * By default, \`PanResponder\` holds an \`InteractionManager\` handle to block\\n * long-running JS events from interrupting active gestures.\\n *\\n * It provides a predictable wrapper of the responder handlers provided by the\\n * [gesture responder system](docs/gesture-responder-system.html).\\n * For each handler, it provides a new \`gestureState\` object alongside the\\n * native event object:\\n *\\n * \`\`\`\\n * onPanResponderMove: (event, gestureState) => \{}\\n * \`\`\`\\n *\\n * A native event is a synthetic touch event with the following form:\\n *\\n *  - \`nativeEvent\`\\n *      + \`changedTouches\` - Array of all touch events that have changed since the last event\\n *      + \`identifier\` - The ID of the touch\\n *      + \`locationX\` - The X position of the touch, relative to the element\\n *      + \`locationY\` - The Y position of the touch, relative to the element\\n *      + \`pageX\` - The X position of the touch, relative to the root element\\n *      + \`pageY\` - The Y position of the touch, relative to the root element\\n *      + \`target\` - The node id of the element receiving the touch event\\n *      + \`timestamp\` - A time identifier for the touch, useful for velocity calculation\\n *      + \`touches\` - Array of all current touches on the screen\\n *\\n * A \`gestureState\` object has the following:\\n *\\n *  - \`stateID\` - ID of the gestureState- persisted as long as there at least\\n *     one touch on screen\\n *  - \`moveX\` - the latest screen coordinates of the recently-moved touch\\n *  - \`moveY\` - the latest screen coordinates of the recently-moved touch\\n *  - \`x0\` - the screen coordinates of the responder grant\\n *  - \`y0\` - the screen coordinates of the responder grant\\n *  - \`dx\` - accumulated distance of the gesture since the touch started\\n *  - \`dy\` - accumulated distance of the gesture since the touch started\\n *  - \`vx\` - current velocity of the gesture\\n *  - \`vy\` - current velocity of the gesture\\n *  - \`numberActiveTouches\` - Number of touches currently on screen\\n *\\n * ### Basic Usage\\n *\\n * \`\`\`\\n *   componentWillMount: function() \{\\n *     this._panResponder = PanResponder.create(\{\\n *       // Ask to be the responder:\\n *       onStartShouldSetPanResponder: (evt, gestureState) => true,\\n *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *\\n *       onPanResponderGrant: (evt, gestureState) => \{\\n *         // The guesture has started. Show visual feedback so the user knows\\n *         // what is happening!\\n *\\n *         // gestureState.d\{x,y} will be set to zero now\\n *       },\\n *       onPanResponderMove: (evt, gestureState) => \{\\n *         // The most recent move distance is gestureState.move\{X,Y}\\n *\\n *         // The accumulated gesture distance since becoming responder is\\n *         // gestureState.d\{x,y}\\n *       },\\n *       onPanResponderTerminationRequest: (evt, gestureState) => true,\\n *       onPanResponderRelease: (evt, gestureState) => \{\\n *         // The user has released all touches while this view is the\\n *         // responder. This typically means a gesture has succeeded\\n *       },\\n *       onPanResponderTerminate: (evt, gestureState) => \{\\n *         // Another component has become the responder, so this gesture\\n *         // should be cancelled\\n *       },\\n *       onShouldBlockNativeResponder: (evt, gestureState) => \{\\n *         // Returns whether this component should block native components from becoming the JS\\n *         // responder. Returns true by default. Is currently only supported on android.\\n *         return true;\\n *       },\\n *     });\\n *   },\\n *\\n *   render: function() \{\\n *     return (\\n *       <View \{...this._panResponder.panHandlers} />\\n *     );\\n *   },\\n *\\n * \`\`\`\\n *\\n * ### Working Example\\n *\\n * To see it in action, try the\\n * [PanResponder example in UIExplorer](https://github.com/facebook/react-native/blob/master/Examples/UIExplorer/js/PanResponderExample.js)\\n */\\n",
  "requires": [
    \{
      "name": "./InteractionManager"
    },
    \{
      "name": "TouchHistoryMath"
    }
  ],
  "filepath": "Libraries/Interaction/PanResponder.js",
  "componentName": "PanResponder",
  "componentPlatform": "cross",
  "examples": [
    \{
      "path": "Examples/UIExplorer/js/PanResponderExample.js",
      "title": "",
      "content": "/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * The examples provided by Facebook are for non-commercial testing and\\n * evaluation purposes only.\\n *\\n * Facebook reserves all rights not expressly granted.\\n *\\n * THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL\\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\\n * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n *\\n * @flow weak\\n * @providesModule PanResponderExample\\n */\\n'use strict';\\n\\nvar React = require\('react');\\nvar ReactNative = require\('react-native');\\nvar \{\\n  PanResponder,\\n  StyleSheet,\\n  View,\\n} = ReactNative;\\n\\nvar CIRCLE_SIZE = 80;\\n\\nvar PanResponderExample = React.createClass(\{\\n\\n  statics: \{\\n    title: 'PanResponder Sample',\\n    description: 'Shows the use of PanResponder to provide basic gesture handling.',\\n  },\\n\\n  _panResponder: \{},\\n  _previousLeft: 0,\\n  _previousTop: 0,\\n  _circleStyles: \{},\\n  circle: (null : ?\{ setNativeProps(props: Object): void }),\\n\\n  componentWillMount: function() \{\\n    this._panResponder = PanResponder.create(\{\\n      onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder,\\n      onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,\\n      onPanResponderGrant: this._handlePanResponderGrant,\\n      onPanResponderMove: this._handlePanResponderMove,\\n      onPanResponderRelease: this._handlePanResponderEnd,\\n      onPanResponderTerminate: this._handlePanResponderEnd,\\n    });\\n    this._previousLeft = 20;\\n    this._previousTop = 84;\\n    this._circleStyles = \{\\n      style: \{\\n        left: this._previousLeft,\\n        top: this._previousTop,\\n        backgroundColor: 'green',\\n      }\\n    };\\n  },\\n\\n  componentDidMount: function() \{\\n    this._updateNativeStyles();\\n  },\\n\\n  render: function() \{\\n    return (\\n      <View\\n        style=\{styles.container}>\\n        <View\\n          ref=\{(circle) => \{\\n            this.circle = circle;\\n          }}\\n          style=\{styles.circle}\\n          \{...this._panResponder.panHandlers}\\n        />\\n      </View>\\n    );\\n  },\\n\\n  _highlight: function() \{\\n    this._circleStyles.style.backgroundColor = 'blue';\\n    this._updateNativeStyles();\\n  },\\n\\n  _unHighlight: function() \{\\n    this._circleStyles.style.backgroundColor = 'green';\\n    this._updateNativeStyles();\\n  },\\n\\n  _updateNativeStyles: function() \{\\n    this.circle && this.circle.setNativeProps(this._circleStyles);\\n  },\\n\\n  _handleStartShouldSetPanResponder: function(e: Object, gestureState: Object): boolean \{\\n    // Should we become active when the user presses down on the circle?\\n    return true;\\n  },\\n\\n  _handleMoveShouldSetPanResponder: function(e: Object, gestureState: Object): boolean \{\\n    // Should we become active when the user moves a touch over the circle?\\n    return true;\\n  },\\n\\n  _handlePanResponderGrant: function(e: Object, gestureState: Object) \{\\n    this._highlight();\\n  },\\n  _handlePanResponderMove: function(e: Object, gestureState: Object) \{\\n    this._circleStyles.style.left = this._previousLeft + gestureState.dx;\\n    this._circleStyles.style.top = this._previousTop + gestureState.dy;\\n    this._updateNativeStyles();\\n  },\\n  _handlePanResponderEnd: function(e: Object, gestureState: Object) \{\\n    this._unHighlight();\\n    this._previousLeft += gestureState.dx;\\n    this._previousTop += gestureState.dy;\\n  },\\n});\\n\\nvar styles = StyleSheet.create(\{\\n  circle: \{\\n    width: CIRCLE_SIZE,\\n    height: CIRCLE_SIZE,\\n    borderRadius: CIRCLE_SIZE / 2,\\n    position: 'absolute',\\n    left: 0,\\n    top: 0,\\n  },\\n  container: \{\\n    flex: 1,\\n    paddingTop: 64,\\n  },\\n});\\n\\nmodule.exports = PanResponderExample;\\n"
    }
  ]
}`;
var Post = React.createClass({
  statics: { content: content },
  render: function() {
    return (
      <Layout metadata={{"id":"panresponder","title":"PanResponder","layout":"autodocs","category":"APIs","permalink":"docs/panresponder.html","platform":"cross","next":"permissionsandroid","previous":"netinfo","sidebar":true,"runnable":true,"path":"Libraries/Interaction/PanResponder.js","filename":null}}>
        {content}
      </Layout>
    );
  }
});
module.exports = Post;